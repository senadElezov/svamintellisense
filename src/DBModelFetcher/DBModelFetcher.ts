import { SifrarniksFetcher } from "../SifrarniksFetcher/SifrarniksFetcher";
import { DBType } from '../Types/db-type';
import { Injectable } from '../util-classes/di/injectable';

import { convertDBtoTypeScriptType } from "../Utils/convertDBtoTypeScriptType";
import executeQuery from '../Utils/executeQuery';
import WorkspaceManager, { SISettings } from "../WorkspaceManager";

type dbModelType = {
    columnname: string,
    datatype: string,
    isnullable: boolean,
    tablename: string,
    foreignkeyname?: string
    parentnablename?: string,
    referencedtablename?: string,
    referencedcolumnname?: string,
    parentcolumnname?: string,
    isprimarykey: boolean,
    isautogenerated: boolean
}

type ColumnInfo = {
    dataType: string,
    columnName: string,
    isNullable: boolean
}

type TableInfo = {
    tableName: string,
    columns: ColumnInfo[],
    primaryKeys: {
        columnName?: string,
        isAutoGenerated?: boolean
    }[]
    relations: {
        [relationName: string]: {
            relatedTable?: string,
            columnPairs?: {
                column?: string,
                referencedTableColumn?: string
            }[]
        }
    },
    referencedBy: {
        [relationName: string]: {
            table?: string,
            columnPairs?: {
                column?: string,
                parentTableColumn?: string
            }[]
        }
    },
};

@Injectable()
export class DBModelFetcher {
    private _settings: SISettings | null;
    private _workspaceManager: WorkspaceManager;

    private _typescriptDBModel: { [tableName: string]: ({ columnName?: string, dataType?: string, isNullable?: boolean })[] }
    private _tableInfos: { [tableName: string]: TableInfo }
    constructor(
        private _dbType: DBType,
        private _metadata?: any[]

    ) {
        this._workspaceManager = new WorkspaceManager();
        this._tableInfos = {};
        this._typescriptDBModel = {}
        this._settings = null;
    }

    private async getSettings() {
        this._settings = await WorkspaceManager.getSettings();
    }

    public async fetchDatabaseModel() {
        await this.getSettings();

        const query = `
            SELECT  LOWER(COLUMN_NAME) as column_name,
                    DATA_TYPE,
                    IS_NULLABLE,
                    tableDefs.TABLE_NAME
            FROM	INFORMATION_SCHEMA.COLUMNS as colDefs
                    INNER JOIN INFORMATION_SCHEMA.TABLES as tableDefs ON colDefs.TABLE_NAME = tableDefs.TABLE_NAME
            WHERE	tableDefs.TABLE_TYPE <> 'VIEW'
                    AND LEFT(tableDefs.TABLE_NAME,3)<>'tmp'
                    AND LEFT(tableDefs.TABLE_NAME,1)<>'_'
                    AND LEFT(tableDefs.TABLE_NAME,4) <> 'tUSR'
            `;

        const dbModel = await executeQuery(query, this._dbType)

        this._metadata = dbModel;

        this.loadDbModelToFiles();
    }

    public async metadataToDict() {



        this._metadata?.map((dbModelRow: any) => {

            const {
                table_name,
                column_name,
                is_nullable,
                data_type
            } = dbModelRow;

            const typeScriptDataType = convertDBtoTypeScriptType[data_type];

            if (!this._typescriptDBModel[table_name]) {
                this._typescriptDBModel[table_name] = [];
            }

            this._typescriptDBModel[table_name].push({
                columnName: column_name,
                dataType: typeScriptDataType,
                isNullable: is_nullable
            });

        })
    }

    async loadDbModelToFiles() {

        const repositoryFolderPath = await this._workspaceManager.getRepositoryPath(this._dbType);

        const fullPath = repositoryFolderPath + 'DBModel/';

        const typeExport = 'export type ' + (this._dbType === 'op' ? 'op' : '') + 'DBModel = {';
        let dbModelString = typeExport;

        const tabOut = (times: number) => {
            let returningTabs = '';

            for (let i = 0; i < times; i++) {
                returningTabs += '\t';
            }

            return returningTabs;
        }

        for (const [tableName, columns] of Object.entries(this._typescriptDBModel)) {

            const columnsString = columns
                .map(colDef =>
                    tabOut(2) +
                    colDef.columnName +
                    (colDef.isNullable ? '?' : '') +
                    ':' +
                    colDef.dataType
                ).join('\n');

            const tableDefString = '\n' + tabOut(1) + tableName + '?: {' + '\n' + columnsString + '\n' + tabOut(1) + '}';

            dbModelString += tableDefString;

        }


        dbModelString += '\n};'

        this._workspaceManager.createFile(fullPath + '/DBModel.ts', dbModelString)
    }

    public async fetchEntireDataBaseModel() {
        await this.getSettings();

        const query = `
        SELECT  LOWER(coldefs.name) as columnName,
                typeDefs.name as dataType,
                colDefs.is_nullable as isNullable,
                tableDefs.name as tableName,
                fkMetaData.*,
                pkInfos.*
        FROM	sys.columns as colDefs
                INNER JOIN sys.tables as tableDefs ON colDefs.object_id= tableDefs.object_id
                INNER JOIN sys.types as typeDefs ON typeDefs.user_type_id = colDefs.user_type_id
                INNER JOIN sys.schemas as schemaDefs ON schemaDefs.schema_id = tableDefs.schema_id
                LEFT JOIN (
                    SELECT	fk.name as foreignKeyName,
                            tparent.name as parentTableName,
                            tref.name as referencedTableName,
                            colRef.name as referencedColumnName,
                            colParent.name as parentColumnName,
                            tparent.object_id as parentTableID,
                            colParent.column_id as parentColumnID
                                --tref.name + colParent.name + 'Display' as columnAlias
                    FROM	sys.foreign_key_columns as c 
                            inner join sys.tables as tparent ON c.parent_object_id= tparent.object_id 
                            inner join sys.tables as tref ON c.referenced_object_id=tref.object_id 
                            inner join sys.columns as colParent ON colParent.object_id=tparent.object_id AND colParent.column_id =c.parent_column_id 
                            inner join sys.columns as colRef ON colRef.object_id=tref.object_id AND colRef.column_id=c.referenced_column_id
                            inner join sys.foreign_keys as fk ON c.constraint_object_id = fk.object_id
                ) fkMetaData
                ON	fkMetaData.parentTableID = tableDefs.object_id
                    AND fkMetaData.parentColumnID = colDefs.column_id
                left join (
                    SELECT	c.object_id as tableID,
                            c.column_id as columnID,
                            c.is_identity as isAutoGenerated,
                            i.is_primary_key as isPrimaryKey
                    FROM	sys.indexes as i
                            INNER JOIN sys.index_columns as ic 
                                ON i.index_id = ic.index_id 
                                AND i.is_primary_key = 1
                            INNER JOIN sys.columns as c 
                                ON ic.object_id = c.object_id 
                                AND c.column_id = ic.column_id
                            INNER JOIN sys.tables t 
                                ON c.object_id = t.object_id 
                                AND i.object_id = t.object_id
                ) as pkInfos
                    ON pkInfos.tableID = tableDefs.object_id
                    AND pkInfos.columnID = colDefs.column_id
        WHERE	tableDefs.type_desc <> 'VIEW'
                AND LEFT(tableDefs.name,3)<>'tmp'
                AND LEFT(tableDefs.name,1)<>'_'
                AND LEFT(tableDefs.name,4) <> 'tUSR'
                AND tableDefs.name NOT LIKE '%backup%'
                AND schemaDefs.name IN ('dbo','web')
                AND tableDefs.name NOT IN ('zBat','zBatBaze','zBatRecs','zBatRes','zBaze','zBazeCompare','zConnect','zRDCHistory','zServeri','zServerParametri','zTaskItem','zTaskList','zTaskPrioriteti','zVerzije')
                AND coldefs.name NOT IN ('rv','guid')
                AND tableDefs.object_id IN (SELECT DISTINCT object_id FROM sys.indexes WHERE is_primary_key = 1)
        ORDER BY tableDefs.name`;


        const columnDefinitions = await executeQuery(query, this._dbType);

        this._metadata = columnDefinitions;

        for (let entityIndex = 0; entityIndex < columnDefinitions.length; entityIndex++) {
            const currentColumn = columnDefinitions[entityIndex];

            const tableName = currentColumn.tablename;

            if (!this._tableInfos[tableName]) {
                this._tableInfos[tableName] = {
                    tableName: tableName,
                    columns: [],
                    primaryKeys: [],
                    referencedBy: {},
                    relations: {}
                }
            }
            const tableInfo = this._tableInfos[tableName]

            const isColumnAdded = tableInfo.columns.find(colDef => colDef.columnName === currentColumn.columnname);

            if (!isColumnAdded) {

                tableInfo.columns.push({
                    columnName: currentColumn.columnname,
                    dataType: currentColumn.datatype,
                    isNullable: currentColumn.isnullable
                });
            }


            if (currentColumn.isprimarykey === true) {
                const primaryKeyExists = tableInfo.primaryKeys.find(primKey => primKey.columnName === currentColumn.columnname);

                const typeScriptDataType = convertDBtoTypeScriptType[currentColumn.datatype];

                tableInfo.primaryKeys.push({
                    columnName: currentColumn.columnname,
                    isAutoGenerated: currentColumn.isautogenerated
                });
            }

            if (currentColumn.foreignkeyname) {
                const foreignKeyName = currentColumn.foreignkeyname as string
                if (!tableInfo.relations[foreignKeyName]) {
                    tableInfo.relations[foreignKeyName] = {
                        columnPairs: [],
                        relatedTable: currentColumn.referencedtablename
                    };
                }

                const relation = tableInfo.relations[foreignKeyName];

                const referencedTableName = currentColumn.referencedtablename as string;
                relation.relatedTable = currentColumn.referencedtablename;

                if (!relation.columnPairs) {
                    relation.columnPairs = []
                }

                relation.columnPairs.push({
                    column: currentColumn.parentcolumnname,
                    referencedTableColumn: currentColumn.referencedcolumnname
                })

                if (!this._tableInfos[referencedTableName]) {
                    this._tableInfos[referencedTableName] = {
                        columns: [],
                        primaryKeys: [],
                        referencedBy: {},
                        relations: {},
                        tableName: referencedTableName
                    };
                }

                const referencedTableInfos = this._tableInfos[referencedTableName];

                const referencedTableReferencedBy = referencedTableInfos.referencedBy;

                if (!referencedTableReferencedBy[foreignKeyName]) {
                    referencedTableReferencedBy[foreignKeyName] = {
                        columnPairs: [],
                        table: currentColumn.tablename
                    };
                }

                const foreignKeyDef = referencedTableReferencedBy[foreignKeyName];

                foreignKeyDef.columnPairs?.push({
                    column: currentColumn.referencedcolumnname as string,
                    parentTableColumn: currentColumn.columnname as string
                })
            }




        }

        await this.generateModelType();

    }

    public async generateModelType() {

        const repositoryPath = await this._workspaceManager.getRepositoryPath(this._dbType);

        const fullModelPath = repositoryPath + 'DBModel/';

        const tabOut = (times: number) => {
            let returningTabs = '';

            for (let i = 0; i < times; i++) {
                returningTabs += '\t';
            }

            return returningTabs;
        }

        const typeExport = 'export type ' + (this._dbType === 'op' ? 'op' : '') + ' DBModel = {';
        let dbModelString = typeExport;


        for (const [tableName, tableDef] of Object.entries(this._tableInfos)) {

            const columnsString = tableDef.columns.map(colDef => tabOut(2) + colDef.columnName + (colDef.isNullable ? '?' : '') + ':' + convertDBtoTypeScriptType[colDef.dataType]).join('\n');

            const tableDefString = '\n' + tabOut(1) + tableName + '?: {' + '\n' + columnsString + '\n' + tabOut(1) + '}';

            dbModelString += tableDefString;

        }


        dbModelString += '\n};'
        this._workspaceManager.createFile(fullModelPath + '/DBModel.ts', dbModelString)
    }

    public async generateModelsAndControls() {
        const sifrarnik = new SifrarniksFetcher('standardni');

        await sifrarnik.fetchSifrarnikMetaData(Object.keys(this._tableInfos))

    }


}


