import { SifrarniksFetcher } from "../SifrarniksFetcher/SifrarniksFetcher";

import { convertDBtoTypeScriptType } from "../Utils/convertDBtoTypeScriptType";
import myStringify from "../Utils/myStringify";
import WorkspaceManager, { SISettings } from "../WorkspaceManager";
const fetch = require("node-fetch");

type dbModelType = {
    columnname: string,
    datatype: string,
    isnullable: boolean,
    tablename: string,
    foreignkeyname?: string
    parentnablename?: string,
    referencedtablename?: string,
    referencedcolumnname?: string,
    parentcolumnname?: string,
    isprimarykey: boolean,
    isautogenerated: boolean
}

type ColumnInfo = {
    dataType: string,
    columnName: string,
    isNullable: boolean
}

type TableInfo = {
    tableName: string,
    columns: ColumnInfo[],
    primaryKeys: {
        columnName?: string,
        isAutoGenerated?: boolean
    }[]
    relations: {
        [relationName: string]: {
            relatedTable?: string,
            columnPairs?: {
                column?: string,
                referencedTableColumn?: string
            }[]
        }
    },
    referencedBy: {
        [relationName: string]: {
            table?: string,
            columnPairs?: {
                column?: string,
                parentTableColumn?: string
            }[]
        }
    },
};

export class DBModelFetcher {
    private _settings: SISettings | null;
    private _workspaceManager: WorkspaceManager;

    private _typescriptDBModel: { [tableName: string]: ({ columnName?: string, dataType?: string, isNullable?: boolean })[] }
    private _tableInfos: { [tableName: string]: TableInfo }
    constructor(private _metadata?: any[]) {
        this._workspaceManager = new WorkspaceManager();
        this._tableInfos = {};
        this._typescriptDBModel = {}
        this._settings = null;
    }

    private async getSettings() {
        this._settings = await WorkspaceManager.getSettings();
    }

    public async fetchDatabaseModel() {
        await this.getSettings();
        let settings = this._settings;
        const queryPrepared = [
            {
                query: `SELECT  LOWER(COLUMN_NAME) as column_name,
                                DATA_TYPE,
                                IS_NULLABLE,
                                tableDefs.TABLE_NAME
                        FROM	INFORMATION_SCHEMA.COLUMNS as colDefs
                                INNER JOIN INFORMATION_SCHEMA.TABLES as tableDefs ON colDefs.TABLE_NAME = tableDefs.TABLE_NAME
                        WHERE	tableDefs.TABLE_TYPE <> 'VIEW'
                                AND LEFT(tableDefs.TABLE_NAME,3)<>'tmp'
                                AND LEFT(tableDefs.TABLE_NAME,1)<>'_'
                                AND LEFT(tableDefs.TABLE_NAME,4) <> 'tUSR'
                        `,
                commandtype: 'text'
            }
        ];

        let requestOptions = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': 'Basic dGVzdDoxMjM=' },
            body: JSON.stringify({
                db: settings?.database,
                queries: queryPrepared,
            })
        };

        const response = await fetch(settings?.api, requestOptions);
        const dbModel = await response.json();

        this._metadata = dbModel;

        this.loadDbModelToFiles();
    }

    public async metadataToDict() {

        const convertDBDataType: { [key: string]: string } = {
            bigint: 'number',
            binary: 'string',
            bit: 'boolean',
            char: 'string',
            date: 'Date',
            datetime: 'Date',
            datetime2: 'Date',
            decimal: 'number',
            float: 'number',
            hierarchyid: 'number',
            image: 'any',
            int: 'number',
            money: 'number',
            nchar: 'string',
            ntext: 'string',
            numeric: 'number',
            nvarchar: 'string',
            real: 'number',
            smalldatetime: 'Date',
            smallint: 'number',
            smallmoney: 'number',
            text: 'string',
            time: 'datetime',
            timestamp: 'datetime',
            tinyint: 'number',
            uniqueidentifier: 'number',
            varbinary: 'string',
            varchar: 'string',
            xml: 'any',
        }

        this._metadata?.map((dbModelRow: any) => {
            const {
                table_name,
                column_name,
                is_nullable,
                data_type
            } = dbModelRow;
            const typeScriptDataType = convertDBDataType[data_type];

            if (!this._typescriptDBModel[table_name]) {
                this._typescriptDBModel[table_name] = [];
            }

            this._typescriptDBModel[table_name].push({
                columnName: column_name,
                dataType: typeScriptDataType,
                isNullable: is_nullable
            });

        })
    }

    private loadDbModelToFiles() {
        const rootFolder = this._workspaceManager.getRootFolder();
        const MODEL_REPOSITORY_PATH = this._settings?.modelPath || '/app/repository/'
        const MODEL_SUFFIX = 'Model'
        const TYPESCRIPT_SUFFIX = '.ts'
        const rootPath = rootFolder.path;
        const IMPORT_HEADER = 'import { WeakType } from "./Types/WeakType";';

        for (let tableName in this._typescriptDBModel) {
            const columns = this._typescriptDBModel[tableName];
            const fileName = tableName + MODEL_SUFFIX + TYPESCRIPT_SUFFIX;
            const fullPath = rootPath + MODEL_REPOSITORY_PATH + fileName;

            const columnDefinitions: string = columns.map(columnDefinition => {

                const {
                    columnName,
                    dataType,
                    isNullable
                } = columnDefinition;

                return '\t' + columnName + '?: ' + dataType;
            }).join(',\n');

            let fileText = IMPORT_HEADER + '\n\nexport type ' + tableName + MODEL_SUFFIX + ' = WeakType<{\n' + columnDefinitions + '\n}>;'

            this._workspaceManager
            this._workspaceManager.addFile(fullPath, fileText);
        }

    }


    public async fetchEntireDataBaseModel() {
        await this.getSettings();

        const query = `
        SELECT  LOWER(coldefs.name) as columnName,
                typeDefs.name as dataType,
                colDefs.is_nullable as isNullable,
                tableDefs.name as tableName,
                fkMetaData.*,
                pkInfos.*
        FROM	sys.columns as colDefs
                INNER JOIN sys.tables as tableDefs ON colDefs.object_id= tableDefs.object_id
                INNER JOIN sys.types as typeDefs ON typeDefs.user_type_id = colDefs.user_type_id
                INNER JOIN sys.schemas as schemaDefs ON schemaDefs.schema_id = tableDefs.schema_id
                LEFT JOIN (
                    SELECT	fk.name as foreignKeyName,
                            tparent.name as parentTableName,
                            tref.name as referencedTableName,
                            colRef.name as referencedColumnName,
                            colParent.name as parentColumnName,
                            tparent.object_id as parentTableID,
                            colParent.column_id as parentColumnID
                                --tref.name + colParent.name + 'Display' as columnAlias
                    FROM	sys.foreign_key_columns as c 
                            inner join sys.tables as tparent ON c.parent_object_id= tparent.object_id 
                            inner join sys.tables as tref ON c.referenced_object_id=tref.object_id 
                            inner join sys.columns as colParent ON colParent.object_id=tparent.object_id AND colParent.column_id =c.parent_column_id 
                            inner join sys.columns as colRef ON colRef.object_id=tref.object_id AND colRef.column_id=c.referenced_column_id
                            inner join sys.foreign_keys as fk ON c.constraint_object_id = fk.object_id
                ) fkMetaData
                ON	fkMetaData.parentTableID = tableDefs.object_id
                    AND fkMetaData.parentColumnID = colDefs.column_id
                left join (
                    SELECT	c.object_id as tableID,
                            c.column_id as columnID,
                            c.is_identity as isAutoGenerated,
                            i.is_primary_key as isPrimaryKey
                    FROM	sys.indexes as i
                            INNER JOIN sys.index_columns as ic 
                                ON i.index_id = ic.index_id 
                                AND i.is_primary_key = 1
                            INNER JOIN sys.columns as c 
                                ON ic.object_id = c.object_id 
                                AND c.column_id = ic.column_id
                            INNER JOIN sys.tables t 
                                ON c.object_id = t.object_id 
                                AND i.object_id = t.object_id
                ) as pkInfos
                    ON pkInfos.tableID = tableDefs.object_id
                    AND pkInfos.columnID = colDefs.column_id
        WHERE	tableDefs.type_desc <> 'VIEW'
                AND LEFT(tableDefs.name,3)<>'tmp'
                AND LEFT(tableDefs.name,1)<>'_'
                AND LEFT(tableDefs.name,4) <> 'tUSR'
                AND tableDefs.name NOT LIKE '%backup%'
                AND schemaDefs.name IN ('dbo','web')
                AND tableDefs.name NOT IN ('zBat','zBatBaze','zBatRecs','zBatRes','zBaze','zBazeCompare','zConnect','zRDCHistory','zServeri','zServerParametri','zTaskItem','zTaskList','zTaskPrioriteti','zVerzije')
                AND coldefs.name NOT IN ('rv','guid')
                AND tableDefs.object_id IN (SELECT DISTINCT object_id FROM sys.indexes WHERE is_primary_key = 1)
        ORDER BY tableDefs.name`;


        const queryPrepared = [
            {
                query: query,
                tableName: 'infos',
                commandtype: 'text'
            }
        ];

        let requestOptions = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': 'Basic dGVzdDoxMjM=' },
            body: JSON.stringify({
                db: this._settings?.database,
                queries: queryPrepared,
            })
        };

        const response = await fetch(this._settings?.api, requestOptions);



        const json = await response.json();
        const columnDefinitions: dbModelType[] = json.infos;

        this._metadata = columnDefinitions;

        for (let entityIndex = 0; entityIndex < columnDefinitions.length; entityIndex++) {
            const currentColumn = columnDefinitions[entityIndex];

            const tableName = currentColumn.tablename;

            if (!this._tableInfos[tableName]) {
                this._tableInfos[tableName] = {
                    tableName: tableName,
                    columns: [],
                    primaryKeys: [],
                    referencedBy: {},
                    relations: {}
                }
            }
            const tableInfo = this._tableInfos[tableName]

            const isColumnAdded = tableInfo.columns.find(colDef => colDef.columnName === currentColumn.columnname);

            if (!isColumnAdded) {

                tableInfo.columns.push({
                    columnName: currentColumn.columnname,
                    dataType: currentColumn.datatype,
                    isNullable: currentColumn.isnullable
                });
            }


            if (currentColumn.isprimarykey === true) {
                const primaryKeyExists = tableInfo.primaryKeys.find(primKey => primKey.columnName === currentColumn.columnname);

                const typeScriptDataType = convertDBtoTypeScriptType[currentColumn.datatype];

                tableInfo.primaryKeys.push({
                    columnName: currentColumn.columnname,
                    isAutoGenerated: currentColumn.isautogenerated
                });
            }

            if (currentColumn.foreignkeyname) {
                const foreignKeyName = currentColumn.foreignkeyname as string
                if (!tableInfo.relations[foreignKeyName]) {
                    tableInfo.relations[foreignKeyName] = {
                        columnPairs: [],
                        relatedTable: currentColumn.referencedtablename
                    };
                }

                const relation = tableInfo.relations[foreignKeyName];

                const referencedTableName = currentColumn.referencedtablename as string;
                relation.relatedTable = currentColumn.referencedtablename;

                if (!relation.columnPairs) {
                    relation.columnPairs = []
                }

                relation.columnPairs.push({
                    column: currentColumn.parentcolumnname,
                    referencedTableColumn: currentColumn.referencedcolumnname
                })

                if (!this._tableInfos[referencedTableName]) {
                    this._tableInfos[referencedTableName] = {
                        columns: [],
                        primaryKeys: [],
                        referencedBy: {},
                        relations: {},
                        tableName: referencedTableName
                    };
                }

                const referencedTableInfos = this._tableInfos[referencedTableName];

                const referencedTableReferencedBy = referencedTableInfos.referencedBy;

                if (!referencedTableReferencedBy[foreignKeyName]) {
                    referencedTableReferencedBy[foreignKeyName] = {
                        columnPairs: [],
                        table: currentColumn.tablename
                    };
                }

                const foreignKeyDef = referencedTableReferencedBy[foreignKeyName];

                foreignKeyDef.columnPairs?.push({
                    column: currentColumn.referencedcolumnname as string,
                    parentTableColumn: currentColumn.columnname as string
                })
            }




        }

        // console.log(this._tableInfos);

        await this.generateModelType();

        // await this.generateModelsAndControls();

    }

    public async generateModelType() {
        const rootFolder = this._workspaceManager.getRootFolder();
        const MODEL_REPOSITORY_PATH = this._settings?.modelPath || '/app/repository/DBModel';
        const TYPESCRIPT_SUFFIX = '.ts'
        const rootPath = rootFolder.path;

        const fullModelPath = rootPath + MODEL_REPOSITORY_PATH;

        const tabOut = (times: number) => {
            let returningTabs = '';

            for (let i = 0; i < times; i++) {
                returningTabs += '\t';
            }

            return returningTabs;
        }

        const typeExport = 'export type DBModel = {';
        let dbModelString = typeExport;


        for (const [tableName, tableDef] of Object.entries(this._tableInfos)) {

            const columnsString = tableDef.columns.map(colDef => tabOut(2) + colDef.columnName + (colDef.isNullable ? '?' : '') + ':' + convertDBtoTypeScriptType[colDef.dataType]).join('\n');

            const tableDefString = '\n' + tabOut(1) + tableName + '?: {' + '\n' + columnsString + '\n' + tabOut(1) + '}';

            dbModelString += tableDefString;

        }

        const entityType = 'export type DBEntity = keyof DBModel'

        dbModelString += '\n};'

        // const primaryKeysFile = this.generatePrimaryKeysString();
        // const primaryKeysTypeFile = this.generatePrimaryKeysTypeString();

        this._workspaceManager.createFile(fullModelPath + '/DBModel.ts', dbModelString)
        // this._workspaceManager.createFile(fullModelPath + '/primaryKeysDefinition.ts', primaryKeysFile);
        // this._workspaceManager.createFile(fullModelPath + '/DBPrimaryKeys.ts', primaryKeysTypeFile);
    }

    public async generateModelsAndControls() {
        const sifrarnik = new SifrarniksFetcher();

        await sifrarnik.fetchSifrarnikMetaData(Object.keys(this._tableInfos))

    }

    private tabOut(tabNumber: number) {
        const tab = '\t';

        let returningTabs = '';

        for (let tabIndex = 0; tabIndex < tabNumber; tabIndex++) {
            returningTabs += tab;
        }

        return returningTabs;
    }

    private generatePrimaryKeysString() {
        const primaryKeysDefinitionType = '{[entityName in keyof DBModel]:{columnName:keyof DBModel[entityName],isAutoGenerated:boolean}[]}';

        const primaryKeysImport = 'import { DBModel } from "./DBModel"\n\n';
        const primaryKeysExport = 'export const primaryKeysDefinition:' + primaryKeysDefinitionType + '= {\n';

        const mainString = Object
            .entries(this._tableInfos)
            .map(([tableName, tableInfo]) => {

                const {
                    primaryKeys
                } = tableInfo

                if (!primaryKeys) {
                    return '[]';
                }

                const primaryKeyString =
                    primaryKeys.map((primaryKeyInfo) => {

                        return this.tabOut(3) + myStringify(primaryKeyInfo)
                    }).join(',\n')

                return this.tabOut(1) + tableInfo.tableName + ':[\n' + this.tabOut(2) + primaryKeyString + this.tabOut(2) + '\n]';
            })
            .join(',\n');

        return primaryKeysImport + primaryKeysExport + mainString + '\n}'
    }


    private generateForeignKeyTypeString() {

        const foreignKeyTypeExport = 'export type DBForeignKeys = {\n'

        let foreignKeyString = '';
        for (const [tableName, tableInfo] of Object.entries(this._tableInfos)) {

            const {
                relations
            } = tableInfo;

            if (!relations?.length) {
                foreignKeyString += '\n' + this.tabOut(1) + tableName + ': never';

                continue;
            }

            foreignKeyString += this.tabOut(2) + tableName + ':{\n'


            for (const [relatioName, relationDefintion] of Object.entries(relations)) {
                const {
                    columnPairs,
                    relatedTable
                } = relationDefintion
            }

        }
    }
}


