import WorkspaceManager from "../WorkspaceManager";
const fetch = require("node-fetch");

interface SifrarnikColumn {
    dataField: string,
    dataType: 'string' | 'number' | 'boolean' | 'date' | 'datetime',
    caption?: string,
    allowEditing?: boolean,
    allowAdding?:boolean,
    visible?: boolean,
    svamLookup?: {
        entityDataSource?:{
            entity:string
        },
        customDataSource?: {
            storedProcedure: {
                query?: string,
                params: { [key: string]: any }
            }
        }
        valueExpr?: 'value',
        displayExpr?: 'display',
    },
    validationRules?: ({ type: 'required', message: string })[],
    calculateDisplayValue?: string
}

interface SifrarnikControl {
    editorType: 'dxNumberBox' | 'dxSelectBox' | 'dxTextBox' | 'dxCheckBox' | 'dxDateBox',
    dataField: string,
    svamEditorOptions?: {
        entityDataSource:{
            entity:string
        },
        storedProcedure?: {
            query: string,
            params: { [key: string]: any }
        }
    },
    formLabel?: {
        text: string
    },
    editorOptions?: {
        visible?: boolean,
        readOnly?:boolean,
        valueExpr?: 'value',
        displayExpr?: 'display',
    },
    validationRules?: ({ type: 'required', message: string })[]
}

interface SifrarnikMeta {
    columnname: string,
    is_nullable: boolean,
    datatype: string,
    referencedtablename?: string,
}

interface SifrarnikPrimaryKey {
    isautogenerated?: boolean,
    columnname?: string
}


interface SifrarnikData {
    controls: SifrarnikControl[],
    columns: SifrarnikColumn[],
    primaryKeys: SifrarnikPrimaryKey[]
}

export class SifrarniksFetcher {
    private _workspaceManager: WorkspaceManager;
    private _settings: any
    private _sifrarnikData: { [key: string]: SifrarnikData }
    constructor() {
        this._workspaceManager = new WorkspaceManager();
        this._sifrarnikData = {};
    }

    public async fetchSifrarnikMetaData(tables?:string[]) {
        this._settings = await WorkspaceManager.getSettings();
        let settings = this._settings;

        const sifrarnikTables: string[] = tables || [
          'ERM',
          'ER',
          'ERMKalendar',
          'EGLGrupe',
          'EGLGrupe2',
          'ETOSG',
          'ETOS',
          'EVrsteSkarta',
          'ERLSV',
          'ERMGrupe'
        ] 

        const getQueryForTable = (tableName: string) => {
            const queryString = `
            select	cols.name as columnName,
                    cols.is_nullable,
                    tt.name as dataType,
                    foreignKeyColumns.*
            from sys.columns as cols
            left join
            (
            select	colParent.column_id,
                    tparent.object_id,
                    colRef.name as referencedColumnName,
                    tref.name as referencedTableName,
                    colParent.name as parentColumnName,
                    tparent.name as parentTableName
            from	sys.foreign_key_columns as c 
                    inner join sys.tables as tparent ON c.parent_object_id= tparent.object_id 
                    inner join sys.tables as tref ON c.referenced_object_id=tref.object_id 
                    inner join sys.columns as colParent ON colParent.object_id=tparent.object_id AND colParent.column_id =c.parent_column_id 
                    inner join sys.columns as colRef ON colRef.object_id=tref.object_id AND colRef.column_id=c.referenced_column_id

            where	tparent.name='${tableName}'
            ) as foreignKeyColumns
            on	foreignKeyColumns.column_id = cols.column_id
            inner join sys.types as tt on tt.user_type_id = cols.user_type_id
            WHERE   cols.object_id IN (SELECT object_id FROM sys.tables WHERE name = '${tableName}')
                    AND tt.name <> 'timestamp'
                    AND cols.name NOT IN ('rv','guid')
            ORDER BY cols.column_id`;

            return queryString;
        }

        const getQueryForPrimaryKeys = (tableName: string) => {

            const queryString = `
            SELECT	c.name as columnName,
                    c.is_identity as isAutoGenerated
            FROM	sys.indexes as i
                    INNER JOIN sys.index_columns as ic ON i.index_id = ic.index_id AND i.is_primary_key = 1
                    INNER JOIN sys.columns as c on ic.object_id = c.object_id AND c.column_id = ic.column_id
                    INNER JOIN sys.tables t ON c.object_id = t.object_id AND i.object_id = t.object_id
                    INNER JOIN sys.types as tt ON tt.user_type_id = c.user_type_id
            WHERE	t.name = '${tableName}'`;

            return queryString;
        }

        const convertDBDataType: { [key: string]: 'string' | 'number' | 'boolean' | 'date' | 'datetime' } = {
            bigint: 'number',
            binary: 'string',
            bit: 'boolean',
            char: 'string',
            date: 'date',
            datetime: 'date',
            datetime2: 'date',
            decimal: 'number',
            float: 'number',
            hierarchyid: 'number',
            image: 'string',
            int: 'number',
            money: 'number',
            nchar: 'string',
            ntext: 'string',
            numeric: 'number',
            nvarchar: 'string',
            real: 'number',
            smalldatetime: 'date',
            smallint: 'number',
            smallmoney: 'number',
            text: 'string',
            time: 'datetime',
            timestamp: 'datetime',
            tinyint: 'number',
            uniqueidentifier: 'number',
            varbinary: 'string',
            varchar: 'string',
            xml: 'string',
        }

        const dataTypeToEditorType: { [key in 'string' | 'number' | 'boolean' | 'date' | 'datetime']: 'dxNumberBox' | 'dxSelectBox' | 'dxTextBox' | 'dxCheckBox' | 'dxDateBox' } = {
            boolean: 'dxCheckBox',
            date: 'dxDateBox',
            datetime: 'dxDateBox',
            number: 'dxNumberBox',
            string: 'dxTextBox'
        }

        const sifrarnikData: { [key: string]: SifrarnikData } = {}

        for (let index = 0; index < sifrarnikTables.length; index++) {
            const tableName = sifrarnikTables[index];
            const query = getQueryForTable(tableName);


            const queryPrepared = [
                {
                    query: query,
                    commandtype: 'text'
                }
            ]

            let requestOptions = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': 'Basic dGVzdDoxMjM=' },
                body: JSON.stringify({
                    db: settings.database,
                    queries: queryPrepared,
                })
            };

            const response = await fetch(settings.api, requestOptions)
            const metaData = await response.json();

            const primaryKeyQuery = getQueryForPrimaryKeys(tableName);
            const primaryKeyQueryPrepared = [
                {
                    query: primaryKeyQuery,
                    commandtype: 'text'
                }
            ]

            let requestOptionsPK = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': 'Basic dGVzdDoxMjM=' },
                body: JSON.stringify({
                    db: settings.database,
                    queries: primaryKeyQueryPrepared,
                })
            };

            const PKRespons = await fetch(settings.api, requestOptionsPK);
            const primaryKeys = await PKRespons.json();

            const sifrarnikPrimaryKeys: SifrarnikPrimaryKey[] = primaryKeys.map(
                (primaryKeyInfo: SifrarnikPrimaryKey) => {
                    return {
                        columnname: primaryKeyInfo.columnname?.toLowerCase(),
                        isautogenerated: primaryKeyInfo.isautogenerated
                    }
                }
            );
            const sifrarnikControls: SifrarnikControl[] = [];
            const sifrarnikColumns: SifrarnikColumn[] = [];

            metaData.map((metaRow: SifrarnikMeta) => {

                const primaryKey = sifrarnikPrimaryKeys.find(primareyKeyInfo => primareyKeyInfo.columnname?.toLowerCase() === metaRow.columnname.toLowerCase());

                const dataType = convertDBDataType[metaRow.datatype]


                const column: SifrarnikColumn = {
                    dataField: metaRow.columnname.toLowerCase(),
                    dataType: dataType,
                    caption: metaRow.columnname
                }




                const control: SifrarnikControl = {
                    dataField: metaRow.columnname.toLowerCase(),
                    editorType: dataTypeToEditorType[dataType],
                    formLabel: {
                        text: metaRow.columnname
                    },
                }

                if (primaryKey) {

                    const {
                        isautogenerated
                    } = primaryKey

                    column.allowAdding = !isautogenerated;
                    column.allowEditing = false;
                    column.visible = !isautogenerated;

                }

                if (metaRow.is_nullable === false && metaRow.datatype !== 'bit') {
                    column.validationRules = [{
                        type: 'required',
                        message: 'Polje "' + metaRow.columnname + '" je obavezno'
                    }]

                    control.validationRules = [{
                        type: 'required',
                        message: 'Polje "' + metaRow.columnname + '" je obavezno'
                    }]
                }

                if (metaRow.referencedtablename) {
                    column.svamLookup = {
                        entityDataSource:{
                            entity:metaRow.referencedtablename
                        }
                    }

                    column.calculateDisplayValue = (metaRow.referencedtablename + column.dataField + 'Display').toLowerCase();

                    control.svamEditorOptions = {
                        entityDataSource:{
                            entity:metaRow.referencedtablename
                        }
                    }

                    control.editorType = 'dxSelectBox'
                    if(!control.editorOptions) {
                        control.editorOptions ={};
                    }

                    control.editorOptions.displayExpr = 'display';
                    control.editorOptions.valueExpr = 'value'
                }

                sifrarnikColumns.push(column);
                sifrarnikControls.push(control);
            
            })

            sifrarnikData[tableName] = {
                primaryKeys: sifrarnikPrimaryKeys,
                columns: sifrarnikColumns,
                controls: sifrarnikControls,
            }

        }

        this._sifrarnikData = sifrarnikData;
        this.saveSifrarnikMetaDataToFiles();
    }

    private saveSifrarnikMetaDataToFiles() {
        const rootFolder = this._workspaceManager.getRootFolder();
        const SIFRARNICI_FOLDER_PATH = '/app/modules/Proizvodnja/Sifrarnici/'
        const TYPESCRIPT_SUFFIX = '.ts'
        const rootPath = rootFolder.path;
        // const IMPORT_HEADER = 'import { WeakType } from "./Types/WeakType";';
        const fullPath = rootPath + SIFRARNICI_FOLDER_PATH;

        const transformJson = (json: string) => {

            const jsonLineArray = json.split('\n');

            const transformedJsonArray: string[] = [];
            jsonLineArray.map(jsonLine => {
                if (jsonLine.indexOf(':') < 0) {
                    transformedJsonArray.push(jsonLine);
                    return
                }

                const [key, value] = jsonLine.split(':');

                const replacedKey = key.replace(new RegExp('"', 'g'), '');

                const replacedValue = value.replace(new RegExp('"', 'g'), '\'');

                transformedJsonArray.push(replacedKey + ':' + replacedValue);

            });

            const transformedJson = transformedJsonArray.join('\n');
            return transformedJson;
        }

        for (const [tableName, sifrarnikData] of Object.entries(this._sifrarnikData)) {

            const tableFullPath = fullPath + tableName;
            this._workspaceManager.addFolder(tableFullPath);

            const getColumnsString = (columns: SifrarnikColumn[]) => {
                const columnsImportHeader = 'import { ISvamColumnOptions } from "@svam/components/SvamGridTS/SubComponents/SvamColumn/Interfaces/ISvamColumnOptions"';

                const columnJson = JSON.stringify(columns, null, "\t");
                const columnsString = columnsImportHeader + '\n\nexport const ' + tableName + 'Columns:ISvamColumnOptions[] = ' + transformJson(columnJson);
                return columnsString;
            }

            const getControlsString = (controls: SifrarnikControl[]) => {
                const controlsImportHeader = 'import { IEditorProps } from "@svam/forms/SvamForm/SubComponents/Editors/EditorProps/IEditorProps"';
                let returningControlsString = controlsImportHeader + '\n\nexport const ' + tableName + 'Controls = [\n'

                controls.map(control => {
                    const controlJson = JSON.stringify(control, null, '\t');
                    returningControlsString += transformJson(controlJson) + ' as IEditorProps<\'' + control.editorType + '\'>,';
                })

                returningControlsString += '\n];'

                return returningControlsString;
            }

            const getPrimaryKeysString = (primaryKeys: SifrarnikPrimaryKey[]) => {

                const primaryKeyJson = JSON.stringify(primaryKeys, null, '\t');
                const primaryKeysString = '\nexport const ' + tableName + 'PrimaryKeys = ' + transformJson(primaryKeyJson);

                return primaryKeysString;

            }

            const columnsString = getColumnsString(sifrarnikData.columns);
            const controlsString = getControlsString(sifrarnikData.controls);
            const primaryKeysString = getPrimaryKeysString(sifrarnikData.primaryKeys)
            this._workspaceManager.addFile(tableFullPath + '/' + tableName + 'Columns' + TYPESCRIPT_SUFFIX, columnsString)
            this._workspaceManager.addFile(tableFullPath + '/' + tableName + 'Controls' + TYPESCRIPT_SUFFIX, controlsString)
            this._workspaceManager.addFile(tableFullPath + '/' + tableName + 'PrimaryKeys' + TYPESCRIPT_SUFFIX, primaryKeysString)
        }

        const getSifrarnikImports = () => {
            const sifrarnikTables = Object.keys(this._sifrarnikData);

            const importArray = sifrarnikTables.map(tableName => {
                return 'import {' + tableName + 'Columns} from "./' + tableName + '/' + tableName + 'Columns"\n' +
                    'import {' + tableName + 'Controls} from "./' + tableName + '/' + tableName + 'Controls"\n' +
                    'import {' + tableName + 'PrimaryKeys} from "./' + tableName + '/' + tableName + 'PrimaryKeys"\n'
            });

            return importArray.join('\n')

        }

        const getSifrarnikJson = () => {
            const sifrarnikTables = Object.keys(this._sifrarnikData);

            let sifrarnikText = 'export const proizvodniSifrarniciDefinitions = {\n'

            let sifrarnikArray = sifrarnikTables.map(tableName => {
                let returningString = '\t' + tableName + ':{\n'
                returningString += '\t\tcontrols:' + tableName + 'Controls,\n'
                returningString += '\t\tcolumns:' + tableName + 'Columns,\n'
                returningString += '\t\tprimaryKeys:' + tableName + 'PrimaryKeys\n'

                return returningString + '}';
            })

            sifrarnikText += sifrarnikArray.join(',\n');
            sifrarnikText += '\n}';
            return sifrarnikText;
        }

        this._workspaceManager.addFile(fullPath + 'proizvodniSifrarniciDefinitions.ts', getSifrarnikImports() + '\n\n' + getSifrarnikJson())

    }

 
}


